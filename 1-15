module PartOne where


main :: IO ()
main = undefined


-- Problem 1: Find the last element of a list 
myLast :: [a] -> Maybe a
myLast []     = Nothing
myLast [x]    = Just x
myLast (x:xs) = myLast xs

-- Problem 2: Find the last but one element of a list 
myButLast :: [a] -> Maybe a
myButLast list = case list of
    []     -> Nothing
    [x]    -> Nothing
    [x,y]  -> Just x
    (x:xs) -> myButLast xs

-- Problem 3: Find the kth element of a list. The first element in the list is #1.
elementAt :: Int -> [a] -> Maybe a
elementAt _ []     = Nothing
elementAt 1 (x:_)  = Just x
elementAt n (x:xs) = elementAt (n-1) xs

-- Problem 4: Find the # of elements of a list. Don't ask me why it's Int instead of Num, I'm just following instructions. 
myLength :: [a] -> Int
myLength = foldr (\x -> (+1)) 0

-- Problem 5: Reverse a list
myReverse :: [a] -> [a]
myReverse xs = go xs []
    where go [] acc     = acc
          go (x:xs) acc = go xs (x:acc)

-- Problem 6: Find out whether a list is a palindrome. A palindrome can be read forward or backward; e.g. "xamax".
isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs

-- Problem 7: ransform a list, possibly holding lists as elements, into a "flat" list.

data NestedList a = Elem a | List [NestedList a] deriving (Eq,Show)


flatten :: NestedList a -> [a]
flatten nestedlist = case nestedlist of
    List []               -> []
    Elem x                -> [x]
    List (Elem x :xs)     -> x : flatten (List xs)
    List (List x :xs)     -> flatten (List x) ++ flatten (List xs)


-- Problem 8: Eliminate consecutive duplicates of list elements.
compress :: Eq a => [a] -> [a]
compress []  = []
compress [x] = [x]
compress (x:xs)
    | x == head xs = compress xs
    | otherwise    = x : compress xs

-- Problem 9: Pack consecutive duplicates of list elements into sublists.
-- pack "aaabccaadeee" = ["aaa", "b", "cc", "aa", "d", "eee"]

pack :: Eq a => [a] -> [[a]]
pack [] = []
pack (x:xs) = takeWhile (==x) (x:xs) : pack (dropWhile (==x) (x:xs))

-- Problem 10: Use the pack function to implement the so-called run-length encoding data compression method.
-- Consecutive duplicates of elements are encoded as tuples (n, e), where n is the number of duplicates of the element e.

encode :: Eq a => [a] -> [(Int, a)]
encode xs = map length (pack xs) -- Gets the list of lenghts of each sublist of duplicates
            `zip`                -- Joins the length with the letter
            map head (pack xs)   -- Gets the list of letters that make up sublists

tester = "aaabccaadeee"

-- Problem 11: 
-- Modify the encode function in such a way that if an element has no duplicates it is simply copied into the result list. 
-- Only elements with duplicates are transferred as (Multiple n x) values.

data Encoding a = Single a | Multiple Int a deriving (Eq, Show)

encodeModified :: Eq a => [a] -> [Encoding a] 
encodeModified list = [if fst tuple > 1 
                        then uncurry Multiple tuple -- uncurry Multiple x = Multiple (fst x) (snd x)
                        else Single (snd tuple) | tuple <- encode list]


-- Problem 12: Given a run-length code list generated by encodeModified, construct its uncompressed version.
decodeModified :: [Encoding a] -> [a]
decodeModified encodingList = case encodingList of
    []                 -> []
    (Single x : xs)    -> x : decodeModified xs
    (Multiple n x :xs) -> replicate n x ++ decodeModified xs

-- Problem 13: Run-length encoding of a list; direct solution (I don't really understand the question)
encodeDirect :: Eq a => [a] -> [Encoding a]
encodeDirect = encodeModified --I don't really understand what the difference is supposed to be?
    --Even the example input/output was the same for both, sorry

-- Problem 14: Duplicate the elements in a lsit (ex:dupli [1,2,3] = [1,1,2,2,3,3])
dupli :: [a] -> [a] 
dupli = foldr (\x -> (++) [x,x]) [] 

-- Problem 15: Replicate the elemnents in a list a given # of times. 
    -- ex: repli "abc" 3 = "aaabbbccc"
repli :: [a] -> Int -> [a] 
repli [] _     = []
repli _  0     = []
repli (x:xs) n = replicate n x ++ repli xs n  --(replicate :: Int -> a -> [a])
